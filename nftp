#!/bin/bash

# ==== CONFIG & VARIABLES ====
SESSION_FILE="$HOME/.nextcloud_session"
GREEN="\033[0;32m"
RED="\033[0;31m"
YELLOW="\033[1;33m"
BLUE="\033[0;34m"
NC="\033[0m"

CURRENT_PATH="/"

# ==== UTILITY FUNCTIONS ====
show_help() {
    echo -e "${YELLOW}===== Nextcloud SFTP CLI Help =====${NC}"
    echo -e "${BLUE}Available Commands:${NC}"
    echo -e "  ls                ${NC}- List files and directories in the current Nextcloud path"
    echo -e "  pwd               ${NC}- Show current Nextcloud directory"
    echo -e "  cd <dir>          ${NC}- Change directory"
    echo -e "  lls               ${NC}- List files and directories in local"
    echo -e "  lpwd              ${NC}- Show current local directory"
    echo -e "  lcd               ${NC}- Change local directory"
    echo -e "  get <file>        ${NC}- Download file to local machine"
    echo -e "  put <local_file>  ${NC}- Upload local file to current Nextcloud directory"
    echo -e "  mkdir <folder>    ${NC}- Create a folder"
    echo -e "  rm <file/folder>  ${NC}- Delete file/folder (confirmation)"
    echo -e "  rmdir <folder>    ${NC}- Delete empty folder (confirmation)"
    echo -e "  help              ${NC}- Show this help"
    echo -e "  exit              ${NC}- Exit CLI"
    echo
}

join_path() {
    local base="$1"
    local part="$2"
    if [[ "$base" == "/" ]]; then
        echo "/$part" | sed 's/\/\//\//g'
    else
        echo "$base/$part" | sed 's/\/\//\//g'
    fi
}

ask_yes_no() {
    local prompt="$1"
    local answer
    while true; do
        read -p "$prompt (Y/n): " answer
        answer=${answer:-y}
        case "$answer" in
            [Yy]) return 0 ;;
            [Nn]) return 1 ;;
            *) echo "Please enter Y or N." ;;
        esac
    done
}

# ==== LOGIN ====
if [[ -f "$SESSION_FILE" ]]; then
    source "$SESSION_FILE"
    if [[ -n "$CREDS" ]]; then
        DISPLAY_USERNAME=$(echo "$CREDS" | base64 --decode | cut -d: -f1)
        echo -e "${YELLOW}Saved session found: ${GREEN}${URL}${NC} as ${GREEN}${DISPLAY_USERNAME}${NC}"
        if ! ask_yes_no "Continue this session?"; then
            rm -f "$SESSION_FILE"
            unset URL CREDS
            echo -e "${YELLOW}Session cleared. Please login again.${NC}"
        fi
    else
        rm -f "$SESSION_FILE"
        unset URL CREDS
    fi
fi

if [[ -z "$URL" ]]; then
    read -p "Enter Nextcloud URL (http/https): " URL
    read -p "Username: " USERNAME
    read -s -p "Password: " PASSWORD
    echo
    CREDS=$(echo -n "$USERNAME:$PASSWORD" | base64)
else
    USERNAME=$(echo "$CREDS" | base64 --decode | cut -d: -f1)
fi

BASE_URL="${URL}/remote.php/dav/files/${USERNAME}"
STATUS=$(curl --connect-timeout 10 -k -H "Authorization: Basic $CREDS" -s -o /dev/null -w "%{http_code}" -X PROPFIND -H "Depth: 1" "${BASE_URL}/")

if [[ "$STATUS" == "207" || "$STATUS" == "200" ]]; then
    echo -e "${GREEN}Login successful!${NC}"
    if [[ ! -f "$SESSION_FILE" ]]; then
        if ask_yes_no "Save session for next time?"; then
            echo "URL=\"$URL\"" > "$SESSION_FILE"
            echo "CREDS=\"$CREDS\"" >> "$SESSION_FILE"
            chmod 600 "$SESSION_FILE"
            echo -e "${GREEN}Session saved to $SESSION_FILE${NC}"
        fi
    fi
elif [[ "$STATUS" == "401" ]]; then
    echo -e "${RED}Login failed: Invalid username or password. Old session cleared.${NC}"
    rm -f "$SESSION_FILE"
    exit 1
elif [[ "$STATUS" == "404" || "$STATUS" == "000" ]]; then
    echo -e "${RED}HTTP_CODE $STATUS: URL not found or server unreachable. Old session cleared.${NC}"
    rm -f "$SESSION_FILE"
    exit 1
fi

trap "echo -e '\n${YELLOW}Cancelled by user.${NC}'; exit 1" SIGINT SIGTERM

# ==== SFTP-LIKE COMMANDS ====

local_ls() {
    ls "${args[@]}"
}

local_cd() {
    cd "${args[@]}" || echo "No such directory: ${args[*]}"
}

ls_command() {
    local target="$1"
    if [[ -z "$target" ]]; then
        target="$CURRENT_PATH"
    fi

    if [[ "$target" == "~" ]]; then
        target="/"
    elif [[ "$target" =~ ^~(/.*)?$ ]]; then
        target="/${target:2}"
    elif [[ "$target" != /* ]]; then
        target=$(join_path "$CURRENT_PATH" "$target")
    fi

    [[ "$target" != "/" ]] && target="${target%/}"
    local encoded_path=${target// /%20}

    local response=$(curl -s -k -H "Authorization: Basic $CREDS" \
        -X PROPFIND -H "Depth: 1" "$BASE_URL$encoded_path/" \
        | grep -oP '(?<=<d:href>).*?(?=</d:href>)')

    local files=() dirs=()
    while read -r line; do
        local name=$(basename "$line" | sed 's/%20/ /g')
        # skip root, username folder, and target itself
        [[ -z "$name" || "$name" == "/" || "$name" == "$USERNAME" || "$name" == "$(basename "$target")" ]] && continue
        [[ "$line" =~ /$ ]] && dirs+=("$name/") || files+=("$name")
    done <<< "$response"

    local combined_list=("${files[@]}" "${dirs[@]}")
    if [[ ${#combined_list[@]} -eq 0 ]]; then
        echo "Directory is empty."
        return
    fi

    printf "%s\n" "${combined_list[@]}" | column -c "$(tput cols)"
}

cd_command() {
    local target="$1"
    if [[ -z "$target" || "$target" == "~" ]]; then
        CURRENT_PATH="/"
        return
    fi

    local new_path
    if [[ "$target" == /* ]]; then
        new_path="$target"
    elif [[ "$target" =~ ^~(/.*)?$ ]]; then
        new_path="/${target:2}"
    else
        new_path=$(join_path "$CURRENT_PATH" "$target")
    fi

    new_path=$(realpath -m "$new_path")
    [[ "$new_path" != "/" ]] && new_path="${new_path%/}"
    local encoded_path=$(echo "$new_path" | sed 's/ /%20/g')
    local status=$(curl --connect-timeout 5 -k -H "Authorization: Basic $CREDS" -s -o /dev/null -w "%{http_code}" -X PROPFIND -H "Depth: 1" "${BASE_URL}${encoded_path}/")

    if [[ "$status" == "207" || "$status" == "200" ]]; then
        CURRENT_PATH="$new_path"
    else
        echo "cd: $target: No such file or directory"
    fi
}

get_command() {
    local remote_file="$1"
    [[ -z "$remote_file" ]] && { echo -e "${RED}Usage: get <filename>${NC}"; return; }
    remote_file="${remote_file%/}"  # remove trailing slash

    local file_path=$(join_path "$CURRENT_PATH" "$remote_file")
    local encoded_path=$(echo "$file_path" | sed 's/ /%20/g')
    local status=$(curl -s -k -o /dev/null -w "%{http_code}" -H "Authorization: Basic $CREDS" "$BASE_URL$encoded_path")
    [[ "$status" == "404" ]] && { echo -e "${RED}File '$remote_file' not found.${NC}"; return; }

    local propfind=$(curl -s -k -H "Authorization: Basic $CREDS" -X PROPFIND -H "Depth: 1" "$BASE_URL$encoded_path/")
    if echo "$propfind" | grep -q "/$remote_file/"; then
        echo -e "${RED}'$remote_file' is not a regular file.${NC}"
        return
    fi

    echo -e "${YELLOW}Downloading '$remote_file'...${NC}"
    curl --progress-bar -f -k -H "Authorization: Basic $CREDS" -o "$remote_file" "$BASE_URL$encoded_path" \
        && echo -e "${GREEN}Download successful: ${remote_file}${NC}" \
        || echo -e "${RED}Download failed.${NC}"
}

put_command() {
    local local_file="$1"
    [[ -z "$local_file" ]] && { echo -e "${RED}Usage: put <local_file>${NC}"; return; }
    [[ ! -f "$local_file" ]] && { echo -e "${RED}$local_file is not a regular file.${NC}"; return; }

    local filename=$(basename "$local_file")
    local upload_url=$(join_path "$CURRENT_PATH" "$filename")
    local encoded_url=$(echo "$upload_url" | sed 's/ /%20/g')

    echo -e "${YELLOW}Uploading '$local_file' to '$CURRENT_PATH'...${NC}"
    curl --progress-bar -f -k -H "Authorization: Basic $CREDS" -T "$local_file" "$BASE_URL$encoded_url" \
        && echo -e "${GREEN}Upload successful: ${local_file}${NC}" \
        || echo -e "${RED}Upload failed.${NC}"
}

mkdir_command() {
    local folder="$1"
    [[ -z "$folder" ]] && { echo -e "${RED}Usage: mkdir <folder>${NC}"; return; }

    local path=$(join_path "$CURRENT_PATH" "$folder")
    local encoded_path=$(echo "$path" | sed 's/ /%20/g')
    local status=$(curl -s -k -X MKCOL -H "Authorization: Basic $CREDS" "$BASE_URL$encoded_path" -w "%{http_code}" -o /dev/null)

    [[ "$status" == "201" || "$status" == "200" ]] && echo -e "${GREEN}Folder '$folder' created.${NC}" || echo -e "${RED}Failed to create '$folder'. HTTP_CODE: $status${NC}"
}

rm_command() {
    local target="$1"
    [[ -z "$target" ]] && { echo -e "${RED}Usage: rm <file/folder>${NC}"; return; }

    local path=$(join_path "$CURRENT_PATH" "$target")
    local encoded_path=$(echo "$path" | sed 's/ /%20/g')
    local header=$(curl -s -k -I -H "Authorization: Basic $CREDS" "$BASE_URL$encoded_path")
    [[ -z "$header" ]] && { echo -e "${RED}'$target' not found.${NC}"; return; }

    ! ask_yes_no "Are you sure to delete '$target'?" && { echo "Cancelled."; return; }

    local status=$(curl -s -k -X DELETE -H "Authorization: Basic $CREDS" "$BASE_URL$encoded_path" -w "%{http_code}" -o /dev/null)
    [[ "$status" == "204" || "$status" == "200" ]] && echo -e "${GREEN}'$target' deleted.${NC}" || echo -e "${RED}Failed to delete '$target'. HTTP_CODE: $status${NC}"
}

rmdir_command() {
    local target="$1"
    [[ -z "$target" ]] && { echo -e "${RED}Usage: rmdir <folder>${NC}"; return; }

    local path=$(join_path "$CURRENT_PATH" "$target")
    local encoded_path=$(echo "$path" | sed 's/ /%20/g')
    local response=$(curl -s -k -H "Authorization: Basic $CREDS" -X PROPFIND -H "Depth: 1" "$BASE_URL$encoded_path/")

    [[ -z "$response" ]] && { echo -e "${RED}'$target' not found.${NC}"; return; }

    local items=$(echo "$response" | grep -oP '(?<=<d:href>).*?(?=</d:href>)' | wc -l)
    [[ $items -gt 1 ]] && { echo -e "${RED}'$target' is not empty.${NC}"; return; }

    ! ask_yes_no "Are you sure to delete folder '$target'?" && { echo "Cancelled."; return; }

    local status=$(curl -s -k -X DELETE -H "Authorization: Basic $CREDS" "$BASE_URL$encoded_path" -w "%{http_code}" -o /dev/null)
    [[ "$status" == "204" || "$status" == "200" ]] && echo -e "${GREEN}Folder '$target' deleted.${NC}" || echo -e "${RED}Failed to delete folder '$target'. HTTP_CODE: $status${NC}"
}

# ==== MAIN LOOP ====
while true; do
    if ! read -rp "nftp:$CURRENT_PATH> " -a input_array; then
        echo
        echo "Goodbye!"
        break
    fi

    [[ ${#input_array[@]} -eq 0 ]] && continue

    cmd="${input_array[0]}"
    args=("${input_array[@]:1}")

    case "$cmd" in
        ls) ls_command "${args[*]}" ;;
        pwd) echo "$CURRENT_PATH" ;;
        cd) cd_command "${args[*]}" ;;
        get) get_command "${args[*]}" ;;
        put) put_command "${args[*]}" ;;
        mkdir) mkdir_command "${args[*]}" ;;
        rm) rm_command "${args[*]}" ;;
        rmdir) rmdir_command "${args[*]}" ;;
        lls) local_ls "${args[*]}" ;;
        lpwd) pwd ;;
        lcd) local_cd "${args[*]}" ;;
        clear) clear ;;
        help) show_help ;;
        exit) echo "Goodbye!"; break ;;
        *) [[ -n "$cmd" ]] && echo -e "${RED}Invalid command. Type 'help' for commands.${NC}" ;;
    esac
done
